;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Funzioni utili ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(proclaim '(inline r1 casuale+- casuale-tra divisione-modulo conta-i-positivi abs1 non-presente			ordina-indici i-primi divcon0 log0 multiplop compresop riscala));;;;;;;;;;;;; da un numero casuale fra 0 e 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun r1 ()    (/ (random 1000) 1000.0))    ;;;;;;;;;;;;; restituisce a caso il numero 1 oppure -1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; prop indica la percentuale di 1 contro -1 ;;;;;;;;;;;;;;;;;(defun casuale+- (prob)    (let ((num (r1)))      (if (> prob num)        1        -1)))      ;;;;;;;;;;;;; restituisce un numero casuale fra min e max ;;;;;;;;;;;;;;;(defun casuale-tra (min max)    (let ( (num (random (- max min))) )      (+ num min)))      ;;;;;;;;;;;;; restituisce l'intero pi vicino ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; della divisione di num / modulo ;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun divisione-modulo (num modulo)      (first (list (round num modulo))));;;;;;;;;;;;;; conta i numeri positivi di una lista ;;;;;;;;;;;;;;;;;;;;;(defun conta-i-positivi (lista)    (if (null lista)      0      (if (> (car lista) 0)        (+ 1 (conta-i-positivi (cdr lista)))        (conta-i-positivi (cdr lista)))))                        ;;;;; valore assoluto solo quando c' ;;;;;;;;;;;;;;;;;;;            (defun abs1 (a)              (if a                  (abs a)))                              ;;;;;;;;; da vero se l'elemento non c' in lista, falso altrimenti ;;;;;;;;;;;;;;;;;;;;;;;;(defun non-presente (ele lista)              (cond ((null lista) t)                    ((member ele lista) nil)                    (t nil)))                    ;;;;;;;; restituisce la lista degli indici degli elementi di lista dal pi grande al pi piccolo                    (defun ordina-indici (lista)       (let ((limite (length lista)))         (labels ((ordina (l conto)                    (let ((maggiore (position (reduce #'max l) l)))                      (if (> conto limite)                        nil                        (cons maggiore (ordina (substitute -1 maggiore l :count 1) (+ 1 conto)))))))           (ordina lista 1))));;;;;;;;;;;;;;;;;;; restituisce la lista dei primi n elementi di lista ;;;;;;;;;;;;;;;;;;;           (defun i-primi (n lista)              (if (= 0 n)                  nil                (cons (car lista) (i-primi (- n 1) (cdr lista)))));;;;;;;;; divisione protetta (permette la divisione per 0) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun divcon0 (a b)              (if (= 0 b)                  0                (/ a b)));;;;;;;;;; logaritmo di 0 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun log0 (n base)      (if (= 0 n)        0        (log n base)))                                         ;;;;;;;;;;;;;;;;;;;;;;;;; restituisce t se a  multiplo di b, nil altrimenti ;;;;;;;;;;;;;;;;;;;;;;;;(defun multiplop (a b)                   (integerp (/ a b)))                                      ;;;;;;;;;;;;;;;;;;;;;;;; restituisce t se tra  compreso fra val1 e val2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compresop (tra val1 val2)	(if (> val1 val2)		(and (> tra val2) (< tra val1))		(and (< tra val2) (> tra val1))))		                     ;;;;;;;;;;;;;; riscala i valori di lista fra 0 e 1. zero  il valore ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; che nella lista riscalata deve essere uguale a 0 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; il valore pi lontano possibile da questo zero sarˆ 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Es.: se zero = 0.6 0.7 diventa 0.5, 0.6 diventa 0 e 0 diventa 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun riscala (valore zero)    (let ((nuovo-valore (abs (- zero valore))))      (if (> zero 0.5)        (divcon0 nuovo-valore zero)        (divcon0 nuovo-valore (- 1 zero)))))            (defmethod! dur-not-union ((l1 list) (l2 list))   :initvals '(() ())   :indoc '("durations list" "notes list")   :icon 242   :doc "unisce ogni elemento positivo di l1 con il rispettivo di l2, un elemento negativo viene lasciato solo   Inputs (left to right)   dur. list of duration for notes. negative value for pauses   note. list of pitches   Outputs (left to right)   phrase. list of lists."                (let ((ris nil) (ind 0))                (dolist (elemento l1 ris)                  (cond ((< elemento 0) (push (list elemento) ris))                        (t (push (list elemento (nth ind l2)) ris)                           (setf ind (+ 1 ind))))                  ris)                (nreverse ris)))                                (defmethod! separator ((cromosomes list))   :initvals '(())   :indoc '("cromosomes")   :numouts 4   :icon 242   :doc "separa una lista di liste di frasi in lista durate, lista altezze, lista elementi positivi, lista elementi negativi   Inputs (left to right)   cromosomes. list of list: generation of cromosomes   Outputs (left to right)   duration. list of lists of duration.   pitches. list of list of pitches   note. list of list of notes in the form (duration pitches)   rests. list of list of rests"                        (let ((tutto (divide cromosomes)))      	(values (mapcar #'car tutto) (mapcar #'second tutto) (mapcar #'caddr tutto) (mapcar #'cadddr tutto))))          (defun separatore (crom)	(let ((durate nil) (altezze nil) (note nil) (pause nil))		(dolist (x crom (values (nreverse durate) (nreverse altezze) (nreverse note) (nreverse pause)))			(let ((durata (car x)))				(cond ((> durata 0) (push durata durate)									(push (second x) altezze)									(push x note))					  (t (push durata durate)					  	 (push durata pause)))))))(defun divide (cromosomes)    (if (null cromosomes)      nil      (let ((attuale (multiple-value-list (separatore (car cromosomes)))))        (cons attuale (divide (cdr cromosomes))))))(defmethod! scale1 (&rest fit-val)   :initvals '(())   :numouts 1   :icon 242   :doc "somma i punteggi per ogni cromosoma e li riscala fra 0 e 1.   Il valore pi alto in entrata  il pi basso in uscita.   Inputs (left to right)   valori list of list of values. opt-arrow to add one   output. list of fitness values"   (let ((divisore (length fit-val)))      (mapcar #'(lambda (x) (- 1 (/ x divisore))) (apply #'somme fit-val))))            ;;;;;;;; somma per ogni lista tutti i primi, poi i secondi ecc;;;;;;;; es valori sono (1 2 3) (10 20 30) (100 200 300);;;;;;;; (111 222 333) cio (1 + 10 + 100) (2 + 20 + 200) (3 + 30 + 300)                 (defun somme (&rest valori)              (if (null (car valori))                  nil                (cons (reduce #'+ (mapcar #'car valori))                      (apply #'somme (mapcar #'cdr valori)))))                                 ;****************************************************************;                         (defmethod! summ ((values list) &optional absolute?)   :initvals '( () () )   :indoc '("list" "assoluto?")   :numouts 1   :icon 242   :doc "fa la sommatoria. Se absolute?  attivato fa la somma dei valori assoluti   Inputs (left to right)   values. list or list of list of values to sum,    Outputs sum"    (if (null values)      nil      (let ((elemento (car values)))        (if (consp elemento)          (cons (summ elemento absolute?) (summ (cdr values) absolute?))          (reduce #'+ values :key (if absolute? 'abs))))))   ;*********************************************************************************************************************************;;;;;;;;;;;; controllo verticale                          (defmethod! vertical-control ((cromosomes list) (bass list))   :initvals '(() ())   :indoc '("list of cromosomes" "bass line")   :numouts 1   :icon 242   :doc "calcola i semitoni fra due voci sovrapposte   Inputs (left to right)   cromosomes. list of superior lines   bass. bass line   output. list of distances"	(if (null cromosomes)		nil	    (cons (controlla bass (car cromosomes) 0 0) (vertical-control (cdr cromosomes) bass))));;;;UTILITA'			(defun controlla (l-basso l-alto acc-b acc-a)    (if (or (null l-basso)            (null l-alto))      nil									      (let* ((nota-b (car l-basso))             (nota-a (car l-alto))             (dur-b (+ (abs (car nota-b)) acc-b))             (dur-a (+ (abs (car nota-a)) acc-a)))        (cond ((> dur-b dur-a) (cons (confronta nota-a nota-b)                                     (controlla l-basso (cdr l-alto) 0 dur-a)))              ((= dur-b dur-a) (cons (confronta nota-a nota-b)                                     (controlla (cdr l-basso) (cdr l-alto) 0 0)))              (t (cons (confronta nota-a nota-b)                       (controlla (cdr l-basso) l-alto dur-b 0)))))))                       (defun confronta (a b)              (let ((nota1 (second a))                    (nota2 (second b)))                (if (and nota1 nota2)                    (- nota1 nota2)                  0)));*********************************************************************************************************************************;